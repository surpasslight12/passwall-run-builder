name: Build PassWall Installer

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:

jobs:
  build-installer:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Load OpenWrt SDK config
        run: |
          if [ -f config/openwrt-sdk.conf ]; then
            echo "Using config/openwrt-sdk.conf as OpenWrt SDK config"
            # 文件内容为 KEY=VALUE 形式，直接写入 GITHUB_ENV 供后续步骤使用
            cat config/openwrt-sdk.conf | grep -v '^#' | sed '/^$/d' >> "$GITHUB_ENV"
          else
            echo "config/openwrt-sdk.conf not found" >&2
            exit 1
          fi

      - name: Install build dependencies and makeself
        env:
          DEBIAN_FRONTEND: noninteractive
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential libncurses5-dev gawk gettext unzip file \
            libssl-dev wget python3 git ca-certificates makeself zstd

      - name: Build PassWall IPK with OpenWrt SDK
        env:
          TERM: dumb
          DEBIAN_FRONTEND: noninteractive
          CI: 1
        run: |
          set -e
          mkdir -p openwrt-sdk
          cd openwrt-sdk
          echo "Downloading OpenWrt SDK from: $OPENWRT_SDK_URL"
          
          # Determine file extension from URL
          SDK_FILE=$(basename "$OPENWRT_SDK_URL")
          wget "$OPENWRT_SDK_URL" -O "$SDK_FILE"
          
          # Extract based on file extension
          if [[ "$SDK_FILE" == *.tar.zst ]]; then
            tar --use-compress-program=zstd -xf "$SDK_FILE" --strip-components=1
          elif [[ "$SDK_FILE" == *.tar.xz ]]; then
            tar xf "$SDK_FILE" --strip-components=1
          else
            echo "Unsupported SDK archive format: $SDK_FILE" >&2
            exit 1
          fi

          # Initialize feeds configuration from default
          if [ -f feeds.conf.default ]; then
            cp feeds.conf.default feeds.conf
          else
            echo "Warning: feeds.conf.default not found, feeds may not initialize correctly" >&2
          fi

          # Update base feeds needed for SDK compilation
          # Only update feeds, don't install all packages yet (that's the optimization)
          ./scripts/feeds update packages luci

          rm -rf feeds/packages/net/{xray-core,v2ray-geodata,sing-box,chinadns-ng,dns2socks,hysteria,ipt2socks,microsocks,naiveproxy,shadowsocks-libev,shadowsocks-rust,shadowsocksr-libev,simple-obfs,tcping,trojan-plus,tuic-client,v2ray-plugin,xray-plugin,geoview,shadow-tls}
          git clone https://github.com/Openwrt-Passwall/openwrt-passwall-packages package/passwall-packages

          rm -rf feeds/luci/applications/luci-app-passwall
          git clone https://github.com/Openwrt-Passwall/openwrt-passwall package/passwall-luci

          # 如果在 config/openwrt-sdk.conf 中设置了 PASSWALL_LUCI_REF，则将 luci 源码切换到指定分支/tag/commit
          if [ -n "${PASSWALL_LUCI_REF:-}" ]; then
            echo "Using PASSWALL_LUCI_REF=$PASSWALL_LUCI_REF for openwrt-passwall (luci)"
            git -C package/passwall-luci fetch --all --tags
            git -C package/passwall-luci checkout "$PASSWALL_LUCI_REF"
          fi

          ./scripts/feeds update passwall-luci passwall-packages
          
          # Install luci-base first to get host tools like po2lmo
          # These tools are required for building LuCI language packs
          ./scripts/feeds install luci-base
          
          # Install luci-app-passwall which will automatically pull in its dependencies
          # This replaces the previous "install -a -p passwall-packages" which installed
          # ALL packages from passwall-packages feed (not needed, wastes time)
          ./scripts/feeds install luci-app-passwall

          # Generate default configuration and ensure all options are set non-interactively
          # This MUST be done before compiling any packages to avoid menuconfig errors
          # Pipe empty responses to make defconfig to auto-accept all prompts
          # This prevents interactive menuconfig (mconf) from blocking the CI build
          yes '' | make defconfig
          
          # Compile luci-base host tools (includes po2lmo for translation files)
          # This is now done AFTER defconfig to ensure .config exists
          make package/feeds/luci/luci-base/host/compile V=s
          
          # Compile luci-app-passwall and let make automatically build dependencies
          # This replaces 20+ individual package compilation commands with one command
          # that leverages OpenWrt's dependency resolution system
          # 
          # Dependencies compiled automatically include:
          # - chinadns-ng, dns2socks, ipt2socks, microsocks, tcping
          # - shadowsocks-libev, shadowsocks-rust, shadowsocksr-libev
          # - xray-core, sing-box, v2ray-*, trojan-plus, hysteria, etc.
          make package/luci-app-passwall/compile -j"$(nproc)" V=s || {
            echo "Parallel build failed, retrying with single thread for clearer error messages"
            make package/luci-app-passwall/compile V=s
          }
          
          # Build the Chinese language pack (optional, non-critical)
          make package/luci-i18n-passwall-zh-cn/compile -j"$(nproc)" || true

          # 下载并补充官方预编译的依赖包（用于补充编译失败的包）
          # 从 OPENWRT_SDK_URL 提取架构信息
          # SDK URL 格式示例: .../targets/x86/64/... 或 .../targets/ramips/mt7621/...
          TARGET_ARCH=$(echo "$OPENWRT_SDK_URL" | sed -n 's#.*/targets/\([^/]\+\)/\([^/]\+\)/.*#\1#p')
          TARGET_SUBTARGET=$(echo "$OPENWRT_SDK_URL" | sed -n 's#.*/targets/\([^/]\+\)/\([^/]\+\)/.*#\2#p')
          
          # 架构映射：将 OpenWrt target/subtarget 映射到 Passwall 包名
          # x86/64 -> x86_64, ramips/mt7621 -> mipsel_24kc, 等等
          if [ "$TARGET_ARCH" = "x86" ] && [ "$TARGET_SUBTARGET" = "64" ]; then
            ARCH_NAME="x86_64"
          elif [ "$TARGET_ARCH" = "ramips" ] && [ "$TARGET_SUBTARGET" = "mt7621" ]; then
            ARCH_NAME="mipsel_24kc"
          elif [ "$TARGET_ARCH" = "ramips" ] && [ "$TARGET_SUBTARGET" = "mt7620" ]; then
            ARCH_NAME="mipsel_24kc"
          elif [ "$TARGET_ARCH" = "ath79" ] && [ "$TARGET_SUBTARGET" = "generic" ]; then
            ARCH_NAME="mips_24kc"
          elif [ "$TARGET_ARCH" = "bcm27xx" ] || [ "$TARGET_ARCH" = "bcm2708" ]; then
            ARCH_NAME="arm_cortex-a7"
          elif [ "$TARGET_ARCH" = "ipq40xx" ]; then
            ARCH_NAME="arm_cortex-a7_neon-vfpv4"
          else
            # 默认使用 x86_64
            echo "Warning: Unknown architecture ${TARGET_ARCH}/${TARGET_SUBTARGET}, using x86_64 as fallback"
            ARCH_NAME="x86_64"
          fi
          echo "Target architecture: ${TARGET_ARCH}/${TARGET_SUBTARGET} -> Package arch: $ARCH_NAME"

          # 下载官方最新的预编译依赖包
          # 使用最新的稳定版本标签
          PASSWALL_RELEASE="26.1.13-1"
          echo "Downloading prebuilt packages from Passwall release $PASSWALL_RELEASE"
          
          cd "$GITHUB_WORKSPACE"
          mkdir -p prebuilt-packages
          cd prebuilt-packages
          
          # 下载对应架构的预编译包
          PACKAGE_ZIP="passwall_packages_ipk_${ARCH_NAME}.zip"
          DOWNLOAD_URL="https://github.com/Openwrt-Passwall/openwrt-passwall/releases/download/${PASSWALL_RELEASE}/${PACKAGE_ZIP}"
          
          echo "Attempting to download: $DOWNLOAD_URL"
          if wget -q "$DOWNLOAD_URL"; then
            echo "Successfully downloaded $PACKAGE_ZIP"
            unzip -q "$PACKAGE_ZIP"
            
            # 将预编译包复制到 SDK 的 bin/packages 目录，这样 find 命令可以找到它们
            # 检测 SDK 中的架构目录
            SDK_PKG_DIR=$(find "$GITHUB_WORKSPACE/openwrt-sdk/bin/packages" -type d -name "passwall_packages" | head -n1)
            if [ -n "$SDK_PKG_DIR" ]; then
              echo "Copying prebuilt packages to $SDK_PKG_DIR"
              COPIED=$(cp -v *.ipk "$SDK_PKG_DIR/" 2>&1 | wc -l)
              echo "Copied $COPIED prebuilt package(s)"
            else
              # 如果找不到目标目录，创建一个
              mkdir -p "$GITHUB_WORKSPACE/openwrt-sdk/bin/packages/prebuilt/passwall_packages"
              echo "Copying prebuilt packages to bin/packages/prebuilt/passwall_packages"
              COPIED=$(cp -v *.ipk "$GITHUB_WORKSPACE/openwrt-sdk/bin/packages/prebuilt/passwall_packages/" 2>&1 | wc -l)
              echo "Copied $COPIED prebuilt package(s)"
            fi
          else
            echo "Warning: Failed to download $PACKAGE_ZIP, will try with x86_64 as fallback architecture"
            # 尝试通用的 x86_64 包
            PACKAGE_ZIP="passwall_packages_ipk_x86_64.zip"
            DOWNLOAD_URL="https://github.com/Openwrt-Passwall/openwrt-passwall/releases/download/${PASSWALL_RELEASE}/${PACKAGE_ZIP}"
            if wget -q "$DOWNLOAD_URL"; then
              echo "Successfully downloaded $PACKAGE_ZIP (fallback)"
              unzip -q "$PACKAGE_ZIP"
              SDK_PKG_DIR=$(find "$GITHUB_WORKSPACE/openwrt-sdk/bin/packages" -type d -name "passwall_packages" | head -n1)
              if [ -n "$SDK_PKG_DIR" ]; then
                COPIED=$(cp -v *.ipk "$SDK_PKG_DIR/" 2>&1 | wc -l)
                echo "Copied $COPIED prebuilt package(s) (fallback)"
              else
                mkdir -p "$GITHUB_WORKSPACE/openwrt-sdk/bin/packages/prebuilt/passwall_packages"
                COPIED=$(cp -v *.ipk "$GITHUB_WORKSPACE/openwrt-sdk/bin/packages/prebuilt/passwall_packages/" 2>&1 | wc -l)
                echo "Copied $COPIED prebuilt package(s) (fallback)"
              fi
            else
              echo "Warning: Could not download prebuilt packages, will rely on compiled packages only"
            fi
          fi
          
          cd "$GITHUB_WORKSPACE/openwrt-sdk"

          # Create target directories
          mkdir -p "$GITHUB_WORKSPACE/payload" "$GITHUB_WORKSPACE/payload/depends"

          # Copy compiled packages directly from bin/packages
          # This works regardless of architecture or feed directory structure
          find bin/packages -name "luci-app-passwall_*.ipk" -exec cp {} "$GITHUB_WORKSPACE/payload/" \;
          find bin/packages -name "luci-i18n-passwall-zh-cn_*.ipk" -exec cp {} "$GITHUB_WORKSPACE/payload/" \;

          # 只拷贝与官方安装包一致的一组依赖 IPK
          # 精确白名单（使用前缀匹配，允许版本号变化）：
          #   chinadns-ng, dns2socks, geoview, hysteria, ipt2socks, microsocks, naiveproxy,
          #   shadow-tls, shadowsocks-libev-ss-*, shadowsocks-rust-ss*, shadowsocksr-libev-ssr-*,
          #   simple-obfs-client, sing-box, tcping, trojan-plus, tuic-client,
          #   v2ray-geoip, v2ray-geosite, v2ray-plugin, xray-core, xray-plugin
          find bin/packages -type f \( \
              -name 'chinadns-ng_*.ipk' \
           -o -name 'dns2socks_*.ipk' \
           -o -name 'geoview_*.ipk' \
           -o -name 'hysteria_*.ipk' \
           -o -name 'ipt2socks_*.ipk' \
           -o -name 'microsocks_*.ipk' \
           -o -name 'naiveproxy_*.ipk' \
           -o -name 'shadow-tls_*.ipk' \
           -o -name 'shadowsocks-libev-ss-local_*.ipk' \
           -o -name 'shadowsocks-libev-ss-redir_*.ipk' \
           -o -name 'shadowsocks-libev-ss-server_*.ipk' \
           -o -name 'shadowsocks-rust-sslocal_*.ipk' \
           -o -name 'shadowsocks-rust-ssserver_*.ipk' \
           -o -name 'shadowsocksr-libev-ssr-local_*.ipk' \
           -o -name 'shadowsocksr-libev-ssr-redir_*.ipk' \
           -o -name 'shadowsocksr-libev-ssr-server_*.ipk' \
           -o -name 'simple-obfs-client_*.ipk' \
           -o -name 'sing-box_*.ipk' \
           -o -name 'tcping_*.ipk' \
           -o -name 'trojan-plus_*.ipk' \
           -o -name 'tuic-client_*.ipk' \
           -o -name 'v2ray-geoip_*.ipk' \
           -o -name 'v2ray-geosite_*.ipk' \
           -o -name 'v2ray-plugin_*.ipk' \
           -o -name 'xray-core_*.ipk' \
           -o -name 'xray-plugin_*.ipk' \
          \) -exec cp {} "$GITHUB_WORKSPACE/payload/depends/" \;

          # 去重：如果存在同一个包的多个版本，只保留版本号最高的那个
          # 遍历每个包名前缀，检查是否有多个版本
          cd "$GITHUB_WORKSPACE/payload/depends/"
          for pkg_prefix in chinadns-ng dns2socks geoview hysteria ipt2socks microsocks naiveproxy \
                            shadow-tls shadowsocks-libev-ss-local shadowsocks-libev-ss-redir shadowsocks-libev-ss-server \
                            shadowsocks-rust-sslocal shadowsocks-rust-ssserver \
                            shadowsocksr-libev-ssr-local shadowsocksr-libev-ssr-redir shadowsocksr-libev-ssr-server \
                            simple-obfs-client sing-box tcping trojan-plus tuic-client \
                            v2ray-geoip v2ray-geosite v2ray-plugin xray-core xray-plugin; do
            # 查找该包的所有版本，使用数组避免解析 ls 输出
            pkg_files=("${pkg_prefix}"_*.ipk)
            # 检查是否真的找到了文件（globbing 失败时会返回模式本身）
            if [ -e "${pkg_files[0]}" ]; then
              # 计算有多少个版本
              file_count=${#pkg_files[@]}
              if [ "$file_count" -gt 1 ]; then
                echo "Found multiple versions of $pkg_prefix:"
                printf '%s\n' "${pkg_files[@]}"
                # 按版本号排序，保留最新的（最后一个），删除其他的
                # 使用 sort -V 进行版本号排序
                latest=$(printf '%s\n' "${pkg_files[@]}" | sort -V | tail -n1)
                echo "Keeping latest version: $latest"
                for f in "${pkg_files[@]}"; do
                  if [ "$f" != "$latest" ]; then
                    echo "Removing older version: $f"
                    rm -f "$f"
                  fi
                done
              fi
            fi
          done
          cd "$GITHUB_WORKSPACE/openwrt-sdk"

          # 如果没有找到任何依赖，直接报错退出，避免生成只有主包没有依赖的安装器
          DEP_COUNT=$(find "$GITHUB_WORKSPACE/payload/depends/" -name "*.ipk" | wc -l)
          if [ "$DEP_COUNT" -eq 0 ]; then
            echo "Error: no dependency IPK files were found and copied into payload/depends" >&2
            exit 1
          fi
          
          # 建议至少应该有 23 个依赖包（包括预编译包补充）
          # 对于 x86_64 架构，标准配置应该有 23 个包
          if [ "$DEP_COUNT" -lt 23 ]; then
            echo "Warning: Only $DEP_COUNT dependency packages found. Expected at least 23 packages."
            echo "This may indicate that some packages failed to compile and prebuilt packages were not downloaded successfully."
            echo "Current packages:"
            ls -1 "$GITHUB_WORKSPACE/payload/depends/" | sort
          fi

          echo "Packages copied successfully:"
          ls -lh "$GITHUB_WORKSPACE/payload/"
          echo "Dependencies count: $(find "$GITHUB_WORKSPACE/payload/depends/" -name "*.ipk" | wc -l)"
          echo "All dependencies found:"
          ls -1 "$GITHUB_WORKSPACE/payload/depends/" | sort

      - name: Validate payload
        run: |
          ls -l payload
          test -f payload/install.sh
          test -f payload/luci-app-passwall_*.ipk
          test -f payload/luci-i18n-passwall-zh-cn_*.ipk
          test -d payload/depends

      - name: Prepare payload
        run: |
          mkdir -p build/payload
          cp -r payload/* build/payload/
          chmod +x build/payload/install.sh

      - name: Build self-extracting installer
        run: |
          cd build
          # 从 luci-app-passwall_*.ipk 文件名中抽取版本号，例如：
          # luci-app-passwall_26.1.25-r1_all.ipk -> 26.1.25
          PW_FULL=$(ls payload | grep 'luci-app-passwall_' | head -n1 | awk -F'[_]' '{print $2}')
          PW_VER=${PW_FULL%%-*}
          # 从 OPENWRT_SDK_URL 提取架构与 SDK 版本
          ARCH_SEG=$(echo "$OPENWRT_SDK_URL" | sed -n 's#.*/targets/\([^/]\+/[^/]\+\)/.*#\1#p')
          if [ -z "$ARCH_SEG" ]; then
            ARCH="unknown"
          else
            ARCH=$(echo "$ARCH_SEG" | tr '/' '_')
          fi

          SDK_VERSION=$(echo "$OPENWRT_SDK_URL" | sed -n 's#.*/openwrt-sdk-\([0-9.]\+\)-.*#\1#p')
          if [ -z "$SDK_VERSION" ]; then
            SDK_VERSION="unknown"
          fi

          RUN_NAME="passwall_${PW_VER}_${ARCH}_sdk_${SDK_VERSION}.run"
          LABEL="passwall_${PW_VER}_with_sdk_${SDK_VERSION}"
          echo "RUN_NAME=${RUN_NAME}" >> $GITHUB_ENV
          echo "LABEL=${LABEL}" >> $GITHUB_ENV
          makeself --nox11 \
            payload \
            "../${RUN_NAME}" \
            "${LABEL}" \
            ./install.sh

      - name: Verify installer
        run: |
          file "${RUN_NAME}"
          sh "${RUN_NAME}" --info
          sh "${RUN_NAME}" --check

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.RUN_NAME }}
          path: ${{ env.RUN_NAME }}

      - name: Create GitHub Release
        if: startsWith(github.ref, 'refs/tags/')
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ github.ref_name }}
          files: |
            ${{ env.RUN_NAME }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
